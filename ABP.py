import math

import galois
import matplotlib.pyplot as plt
import numpy as np
import numpy.matlib
from numpy import binary_repr
from numpy.random import default_rng
from scipy.special import erfc

# Define the RS code parameters
# n is the lenght
length = 7
# k is the number of information bits
number_of_information_bits = 4
# t is the parity check symbols
parity_check_symbols = length - number_of_information_bits

reed_solomon_code = galois.ReedSolomon(7,4)
# GF=reed_solomon.field
galois_field = galois.GF(2**3)

# define the H matrix but needs to be flipped
H_matrix = reed_solomon_code.H

#GG=rs.G
# change it from the galois field to a numpy array and flip the numpy array
H_matrix_np=np.flip(np.array(H_matrix),axis=1)
#GGG=np.array(GG)
# Define the message
message=galois_field.Random(reed_solomon_code.k)
# Generate a random codeword
random_code_word=reed_solomon_code.encode(message)
# change the random codeword to an numpy array
random_code_word_np=np.array(random_code_word)
# define the snr range
snr_db =np.arange(1.0,10)
# set the snr range
SNR=0
SSNR = 10**(snr_db/10)
#set the BER vector
BER = np.zeros(snr_db.size)

#define the AWGN to addd noisy to the channel
def add_noise(code_word, snr):
    rng = default_rng()
    noise_variance = 1 / (2 * 10**(snr/10))
    noise = rng.normal(scale=np.sqrt(noise_variance/2), size=code_word.shape) +1j * rng.normal(scale=np.sqrt(noise_variance/2), size=code_word.shape)
    return code_word + noise

# change the symbols to binary
def symbols_to_binary(symbols, width=3):
    binary = np.zeros((len(symbols), width), dtype=int)
    for i in range(len(symbols)):
        binary[i] = np.array([int(x) for x in binary_repr(symbols[i], width=3)])
    return binary

field=3
binary_code_word = symbols_to_binary(random_code_word_np, field)

# change to BPSK symbols
bpsk_code_word = 2 * binary_code_word - 1

# received signal
received_signal = add_noise(bpsk_code_word, SNR)

#calculate the log likelihood ratios
def calculate_llr(r):
    p0 = np.exp(-np.abs(r-1)**2/(2*1/(10**(SNR/10))))
    p1 = np.exp(-np.abs(r+1)**2/(2*1/(10**(SNR/10))))
    llr = np.log((1-p0)/p1)
    return llr.real

llr=calculate_llr(received_signal)

#find absolute value for sorting
abllr = abs(llr)
sortedllr = np.indices(abllr.shape)
sortedind = np.argsort(abllr)

#  Preform BIE to the transformed H matrix
def binary_image_expansion(H_matrix, field):
    """
    This function converts decimal and GF symbols into binary bits.
    This binary bits aren't the ones generated by matlab and are in reality
    just 0s and 1s. The function works for up to eight bits only (i.e., b=8).

    Parameters:
        S: The array or matrix to be converted
        b: The number of bits

    Returns:
        B: The output matrix in bits (i.e., 0s and 1s)
    """

    nn = len(H_matrix)
    k = np.arange(1, field+1)
    z = np.zeros((field, nn), dtype=int)

    if field  == 3:
        for j in range(nn):
            if H_matrix[j] == 0:
                z[k-1, j] = [0, 0, 0]
            elif H_matrix[j] == 1:
                z[k-1, j] = [0, 0, 1]
            elif H_matrix[j] == 2:
                z[k-1, j] = [0, 1, 0]
            elif H_matrix[j] == 3:
                z[k-1, j] = [0, 1, 1]
            elif H_matrix[j] == 4:
                z[k-1, j] = [1, 0, 0]
            elif H_matrix[j] == 5:
                z[k-1, j] = [1, 0, 1]
            elif H_matrix[j] == 6:
                z[k-1, j] = [1, 1, 0]
            elif H_matrix[j] == 7:
                z[k-1, j] = [1, 1, 1]
    return z

def perform_binary_image_expansion(H_matrix, field):
    shape = H_matrix.shape
    n = shape[1]

    # Generating GF(2^b) primitive element and bit representation
    a = galois.GF(2**field).primitive_element
    aa = a**np.arange(n[1])
    cx = np.concatenate((aa, aa[:field-1]))
    v = binary_image_expansion(cx, field)

    # Generating 3 by 3 square matrices for each element of the field


    sq = np.zeros((n, field, field), dtype=int)
    for i in range(n):
        if cx[i] != a**(i-1):
            #sq1=sq[i]
            #v1=v[:,i:i+b]
            #sq1[i,:]=v1
            #sq[i]=sq1
            sq[i,:,:] = v[:,i:i+field]

    # Generating Hb matrix
    Hb = np.zeros((parity_check_symbols*field, n*field), dtype=int)
    for i in range(parity_check_symbols):
        for j in range(n):
            for f in range(n):
                 if H_matrix[i,j] == a**(f):
                     Hb[i*field:(i+1)*field,j*field:(j+1)*field]=sq[f,:,:]
                       #if i==1 and j==1:
                           #Hb[:i*b,:j*b:]=sq[f,:,:]
                       #elif i==1 and j>1:
                           #Hb[:i*b,j*b:(j+1)*b]=sq[f,:,:]
                       #elif i>1 and j==1:
                           #Hb[i*b:(i+1)*b,:j*b]=sq[f,:,:]
                       #elif i>1 and j>1:
    return Hb

binary_H_matrix=perform_binary_image_expansion(H_matrix_np,field)

# perfom the gaussian elimination
# check the gaussian elimination and if it works
# return everything to normal after doing the rref
def gfrref(A):
    """
    Compute the row-reduced echelon form of a matrix A over GF(2).

    Parameters:
    A (numpy.ndarray): the matrix to be reduced.
    tol (float): the tolerance for determining if a column is negligible.

    Returns:
    A (numpy.ndarray): the row-reduced echelon form of A.
    jb (list): a list of column indices corresponding to the pivot columns.
    """

    A = np.array(A, dtype=int)%2

    mq, nq = A.shape
    jb = []  # List of pivot column indices
    i=0
    j=0

    while i <= mq and j <= nq:
        # Find the index of the pivot row
        pivot = np.argmax(A[i:mq, j])
        if A[i + pivot, j]:
            # Column is negligible, zero it out
            A[i:, j] = 0
            j += 1
        else:
            # Remember the pivot column index
            jb.append(j)
            # Swap the current row with the pivot row
            A[[i, i + pivot], j:nq] = A[[i + pivot, i], j:nq]
            # Divide the pivot row by the pivot element
            A[i, j:nq] = A[i, j:nq] / A[i, j]
            # Subtract multiples of the pivot row from the other rows
            for k in range(mq):
                if k != i:
                    A[k, j:nq] -= A[k, j] * A[i, j:nq]
            i += 1
            j += 1

    A = np.array(A, dtype=int)

    return A, jb

def gaussian_elimination(matrix):
    # Perform Gaussian elimination
    num_rows, num_cols = matrix.shape
    for col in range(num_cols):
        for row in range(col + 1, num_rows):
            if matrix[row, col] == 1:
                matrix[row] = (matrix[row] + matrix[col]) % 2

    # Back-substitution to obtain reduced row echelon form
    for col in range(num_cols - 1, -1, -1):
        pivot_row = -1
        for row in range(num_rows):
            if matrix[row, col] == 1 and pivot_row == -1:
                pivot_row = row
            elif matrix[row, col] == 1:
                matrix[row] = (matrix[row] + matrix[pivot_row])%2
        if pivot_row != -1:
            matrix[pivot_row] = matrix[pivot_row] / matrix[pivot_row, col]
            for row in range(pivot_row):
                if matrix[row, col] == 1:
                    matrix[row] = (matrix[row] + matrix[pivot_row]) %2

    return matrix

sorted=binary_H_matrix[:,sortedind]
rrref=gaussian_elimination(sorted)

#Sum product Algorithm
def logSPA(H, LLR, iter, alfa):
    """
    This function performs the SPA decoding algorithm in the log domain.
    It is a simplification of the SPA in the log domain.

    Arguments:
    H -- The Binary Parity check matrix
    LLR -- The log likelihood ratios
    iter -- Number of iterations
    alfa -- Damping factor. Not used in decoding of LDPC.

    Returns:
    V -- The output message at the end of the decoding process
    Lj -- The outputted LLRs
    """
    # Initialization
    t,n =H.shape
    Z = np.zeros((t, n))
    Lrij = Z
    Lqji = H * LLR[np.newaxis,:]

    Lj = np.zeros(n)
    Lext = np.zeros(n)

    for it in range(iter):
        # The horizontal step
        for i in range(t):
             cj = np.nonzero(H[i,:])
             #print(cj)
           # indices of nonzeros in each column
        for ij in range(len(cj)-1):

                for ind in range(len(cj)-1):
                    lij = 1
                    if ind != ij: # all bits except bit n
                        lij =lij* np.tanh(Lqji[i, cj[ind]] / 2)
                        #print('lij: \n',lij)
                Lrij[i, cj[ij]] = 2 * np.arctanh(lij) # horizonatl step (CN) update

        # The vertical step
        for j in range(n):
            ri = np.nonzero(H[:,j]) # indices of nonzeros in each row
            print(ri)
            #for ji in range(len(ri)): # subtract Lrij(ri[ji], j) because all bits except bit n
                #Lqji[ri[ji], j] = LLR[j] + np.sum(Lrij[ri, j]) - Lrij[ri[ji], j] # vertical step (VN) update

            # Finding extrinsic info
            Lext[j] = np.sum(Lrij[ri, j])

            # Finding Lj (total LLR)
            Lj[j] = LLR[j] + alfa * Lext[j]

    return Lj

dec=logSPA(rrref,llr,10,0.04)
Vj= (dec>= 0).astype(int)
num_errors=np.sum(dec!=binary_code_word)

def compute_BER(received_bits, transmitted_bits):
    if len(received_bits) != len(transmitted_bits):
        raise ValueError("The lengths of received_bits and transmitted_bits must be equal.")

    error_count = 0
    total_bits = len(received_bits)

    for i in range(total_bits):
        if received_bits[i] != transmitted_bits[i]:
            error_count += 1

    BER = error_count / total_bits
    return BER

Nerr=compute_BER(Vj,binary_code_word)
num_codewords=1000
simalated_ber=Nerr/(num_codewords*length)

#simalated_ber_values.append(simalated_ber)
#increase the transmitted bits to get a batch number of codewords and test the across different SNR values
#BER[itersnrdB] = BER[itersnrdB]+np.sum(Decbits!=Sym) # count number of bit errors
#BER = BER/BlockLength # over the number of total bits
#plt.semilogy(SNRdB,BER,'b.-')
#plt.yscale('log')
#plt.grid(True)
#plt.xlabel('SNR (dB)')
#plt.ylabel('BER')
#plt.title('Hard Decision Decoding')
#plt.show()
#print(sorted)
#rref=gfrref(sorted,x)
#print(rref)
#print(rrref)
#print(dec)
#H_prime=Hbb*llr[np.newaxis,:]
#Nerr

